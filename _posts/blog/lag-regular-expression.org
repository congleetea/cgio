#+TITLE:       正则表达式
#+AUTHOR:      congleetea
#+EMAIL:       congleetea@lee
#+DATE:        2016-11-23 三
#+URI:         /blog/%y/%m/%d/正则表达式
#+KEYWORDS:    tools,regular expression
#+TAGS:        tools, points
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: 正则表达式随记

* 简述
正则表达式（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE）是计算机科学的一个概念。
正则表达式 *使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串* 。在很多文本编辑器里，正则表
达式通常被用来检索、替换那些匹配某个模式的文本。正则表达式就是用于描述这些规则的工具。换句话说，正
则表达式就是记录文本规则的代码。

我们经常在命令行中使用*或者?等通配符来查找文件，和通配符类似，正则表达式也是用来进行文本匹配的工具，
只不过比起通配符，它能更精确地描述你的需求

* 字符总结
** 元字符 metacharacter
| 代码 | 说明                         |
|------+------------------------------|
| .	  | 匹配除换行符以外的任意字符   |
| \w	 | 匹配字母或数字或下划线或汉字 |
| \s	 | 匹配任意的空白符             |
| \d	 | 匹配数字                     |
| \b	 | 匹配单词的开始或结束         |
| ^	  | 匹配字符串的开始             |
| $	  | 匹配字符串的结束             |

** 字符转义
如果你想查找元字符本身的话，这时你就得使用\来取消这些字符的特殊意义。比如要查找.或者\, 就应该用\.和\\,

** 重复次数
| 代码/语法 | 	说明                |
|-----------+-----------------------|
| *         | 		 重复零次或更多次 |
| +	       | 	重复一次或更多次    |
| ?	       | 	重复零次或一次      |
| {n}	     | 	重复 n 次           |
| {n,}	    | 	重复 n 次或更多次   |
| {n,m}	   | 	重复 n 到 m 次      |

** 特定字符
要想查找数字，字母或数字，空白是很简单的，因为已经有了对应这些字符集合的元字符，但是如果你想匹配没有
预定义元字符的字符集合(比如元音字母 a,e,i,o,u),应该怎么办？很简单，你只需要在方括号里列出它们就行了。
eg:

| 匹配英文的元音字母                 | [aeiou]      |
| 匹配标点符号(.或?或!)              | [.?!]        |
| 匹配一个字符范围:0 到 9 的一个数字 | [0-9]等于\d  |
| 匹配字母和数字                        | [a-z0-9A-Z]  |
例子：
\(?0\d{2}[) -]?\d{8}  ： 

第一个\(使用转义字符转义(, 紧接着的?表示重复 0 或 1 次，接着的\d{2}两次数字，紧接着[) -]?匹配后括号或者
-，匹配 0 或 1 次，继续\d{8}表示匹配八个数字。

** 分支条件
上面的表达式既可以匹配像(010)88886666，或 022-22334455，或 02912345678 等电话号码，但是同时也可能匹配 
010)12345678 或(022-87654321 这样的“不正确”的格式。要解决这个问题，我们需要用到分枝条件。正则表达式里的
分枝条件指的是有几种规则，如果满足其中任意一种规则都应该当成匹配，具体方法是用|把不同的规则分隔开。

eg: 0\d{2}-\d{8}|0\d{3}-\d{7}

这个表达式能匹配两种以连字号分隔的电话号码：一种是三位区号，8 位本地号(如 010-12345678)，一种是 4 位区号，
7 位本地号(0376-2233445)。

*使用分枝条件时，要注意各个条件的顺序*, 匹配分枝条件时，将会从左到右地测试每个条件，如果满足了某个分枝的
话，就不会去再管其它的条件了。

** 分组
我们已经提到了怎么重复单个字符（直接在字符后面加上{}限定符就行了）；但如果想要重复多个字符又该怎么办？你
可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行
其它一些操作。

eg: (\d{1,3}\.){3}\d{1,3}  :

匹配一个简单的 IP 地址匹配表达式。请按下列顺序分析它：\d{1,3}匹配 1 到 3 位的数字，(\d{1,3}\.){3}匹配三位
数字加上一个英文句号(这个整体也就是这个分组)重复 3 次，最后再加上一个一到三位的数字(\d{1,3})。

** 反义
有时需要查找不属于某个能简单定义的字符类的字符。比如想查找除了数字以外，其它任意字符都行的情况，这时需要用
到反义：
| 代码/语法	 | 说明                                       |
|-------------+--------------------------------------------|
| \W	        | 匹配任意不是字母，数字，下划线，汉字的字符 |
| \S	        | 匹配任意不是空白符的字符                   |
| \D	        | 匹配任意非数字的字符                       |
| \B	        | 匹配不是单词开头或结束的位置               |
| [^x]        | 	匹配除了 x 以外的任意字符                  |
| [^aeiou]	  | 匹配除了 aeiou 这几个字母以外的任意字符      |

例子：

\S+匹配不包含空白符的字符串。

<a[^>]+>匹配用尖括号括起来的以 a 开头的字符串。

** 后向引用
这是针对分组的。

使用小括号指定一个子表达式后，匹配这个子表达式的文本(也就是此分组捕获的内容)可以在表达式或其它程序中作进一
步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组
的组号为 1，第二个为 2，以此类推。

表 4.常用分组语法
| 分类	     | 代码/语法	说明                                                                   |
| 捕获	     | (exp)	匹配 exp,并捕获文本到自动命名的组里                                        |
|            | (?<name>exp)	匹配 exp,并捕获文本到名称为 name 的组里，也可以写成(?'name'exp)     |
|            | (?:exp)	匹配 exp,不捕获匹配的文本，也不给此分组分配组号                          |
| 零宽断言	 | (?=exp)	匹配 exp 前面的位置                                                      |
|            | (?<=exp)	匹配 exp 后面的位置                                                     |
|            | (?!exp)	匹配后面跟的不是 exp 的位置                                              |
|            | (?<!exp)	匹配前面不是 exp 的位置                                                 |
| 注释	     | (?#comment)	这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |

- 捕获
捕获用于设置分组的命名规则。

- 零宽断言
这四个表达式用来查找某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像\b,^,$那样用于指定一个位置，
这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。

- 负向零宽断言
确保某个字符没有出现，但并不想去匹配它。

| 零宽度负预测先行断言(?!exp)  |
| 零宽度负回顾后发断言(?<!exp) |

\b\w*q(?!u)\w*\b  ： 匹配包含后面不是字母 u 的字母 q 的单词。

- 注释
小括号的另一种用途是通过语法(?#comment)来包含注释。例如：2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)。

** 贪婪与懒惰
这是针对字符的。

比如在 aabab 中我们要匹配以 a 开头，b 结尾的字符串，就可能出现两种匹配结果：aab 或者 aabab。
通常情况下是贪婪模式 a.*b，也就是得到尽可能长的结果。如果需要得到尽可能短的结果就使用懒惰模式 a.*?b。

表 5.懒惰限定符
| 代码/语法	 | 说明                            |
|-------------+---------------------------------|
| *?	        | 重复任意次，但尽可能少重复      |
| +?	        | 重复 1 次或更多次，但尽可能少重复 |
| ??	        | 重复 0 次或 1 次，但尽可能少重复    |
| {n,m}?	    | 重复 n 到 m 次，但尽可能少重复      |
| {n,}?	     | 重复 n 次以上，但尽可能少重复     |

* references
| [[http://deerchao.net/tutorials/regex/regex.htm][正则表达式 30 分钟入门教程]] |
