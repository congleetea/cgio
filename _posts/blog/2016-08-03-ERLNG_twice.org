#+TITLE: 2016-08-03-ERLNG_twice.org
#+AUTHOR: Xuancong Lee 
#+EMAIL:  lixuancong@molmc.com
#+DATE:  Wednesday, August  3 2016 
#+OPTIONS: ^:nil

* 一些概念理解
** 并发和并行 
并行指多个任务在同一时刻同时发生，而并发形容多个任务在一个时间段交替进行,同一时间只有一个任务在执行。
** 应用       
Erlang 对相关模块进行打包的一种手段(包括库运用和主动运用) 
** 单例进程和多例进程
有一个疑惑，在 gen_server:start_link 启动的进程中，第一个参数是服务器注册名，如果是多例进程，这不就出现了
进程名相同的情况了吗？

这里是理解错误，看代码也不仔细，我们看到其实单例进程启动的时候使用的是 gen_server:start_link/4,而多例进程
使用的是 gen_server:start_link/3,也就是后者缺少前者的第一个参数 ServerName, 这样这个 gen_server 进程就不会被
注册。单例进程会以第一个参数进行注册，多例进程则不会被注册。单例进程可以通过注册名知道消息该发往何处，多
例进程就只有在用户 API 中把需要发往的 PID 作为参数传递进来, 否则不知道消息发给谁，所以客户端要自行维护这些标
识符(比如把者写 PID 和对应进程保存在某个数据库中)。

** 资源探测
就是建立资源提供方和资源使用方之间的关系。

** 同步通信和异步通信
*** 异步通信也叫“即发即忘”
发送完就不管了，接着做自己的事，稍后接收方可能会发送一个响应回来,也有可能不会发送。
*** 同步通信 
同步通信总可以利用成对的异步请求/响应消息来模拟。gen_server:call/3 就是这样做的。
*** 建议
| 除非万不得已，否则尽量采用异步通信. |
| 使用同步通信，一定要与超时配合使用. |
*** 异步缓存
异步缓存容易出现的情况是，用户登陆了，但是登陆信息还没有同步到其他节点的时候，如果用户就请求其他信息，就
有可能提示用户没有登陆。
*** 同步缓存
所有缓存实例都必须都拿到会话数据之后，系统才会告知用户登陆成功。也就是执行插入操作的函数必须线收到所有缓存
实例的确认消息才能进行下一步操作。

* 我的理解
** 关于进程隔离
这得先从并发说起，总所周知，erlang 就是处理并发的语言，并发要求多个任务在 cpu 上轮流执行，那就
得考虑进程之间的执行先后是否会有影响，如果有影响，并发就不能那么随意了，这就是我们要解决的
问题中所隐含的依赖关系。Erlang 为了使代码在硬件上运行得更高效，于是考虑消减任务之间不必要的
依赖。这样将程序中内聚性低的部分隔离成独立的任务，最重要的好处是代码清晰可读。

另外，进程拥有自己的内存空间和消息信箱，避免其他语言中相互踩脚趾的情况，单个进程出问题也不会
影响其他进程。

进程间不共享状态，那么进程的交流就只能通过复制消息来实现(复制式通信), 所以要控制消息的大小，
消息太大会占用太多内存。

创建进程只需要几百字节栈空间，而且可以自动按需伸缩，不像操作系统的线程要分配几 M 栈空间，溢出之后
线程就崩溃了。

进程的隔离的结果就是 erlang 的容错特性。

** 容错特性
异常处理机制来捕获特定代码段的错误；
进程链接系统处理进程故障。

进程链接的工作原理：进程以外退出时会发送一个退出信号，所有和这个濒死进程链接的进程都会收到消息，
并一并退出，同时给与其相链接的进程发送退出信号。这样真个进程组都会被清理。

这样就有一个问题，有时候不需要把所有建立链接的进程都杀死。OTP 实现容错的主要途径是改写退出信号
默认的传播行为。通过设置 trap_exit 进程标记，可以令进程不在服从外来的退出信号，而是将信号捕获。
信号接收者先把信号转化为{'EXIT',Pid,Reason}的消息放到信箱，等待分拣执行特定的操作。

能捕获信号的进程有时被交错系统进程。他可以防范退出信号进一步传播，阻断与之链接的其他进程和外界的
联系，用来汇报故障乃至重启故障的子系统。这样的进程我们称为监督者。这就引申出了监督机制。

监督者和子进程存在链接，但是子进程崩溃，监督者不会崩溃，而是捕捉退出信号，将和这个子进程有链接
的其他进程杀死，并重新启动。 这只重启小部分的进程，也就是 Erlang 的进程链接和监督者共同提供了一种
细粒度的“重启”机制。  这些功能都已由 OTP 给你提供了接口，用起来非常方便。并且功能还很多，他可以根据
你预设的重启方式(包括什么顺序，重启频率)等来重启。

系统还可能有多层的监督者，用多层监督树在多个层级重启子系统来解决各种以外问题。这就是进程的分层容错。
理解分层容错只要分清同一个监督者的辖区就好了，因为崩溃的进程辖区内的其他还存活的进程都会被重启。

一台机器上的进程之间可以通过监督树来实现容错，保证这台机器上的工作正常，但是他们依然公用相同的硬件
设备，如果设备坏了，系统也就无法正常工作了，比如电源线拔了。为了工作不受影响，这就引申出了分布式
erlang。分布式才能实现最高级别的容错，可以令你的解决方案伸缩自如。

* Erlang 语言精要
** Shell 中输入表达式，而非命令
** ++ 的 list 操作为什么耗时？
[1,2,3,4] ++ [5,6,7], 它执行的操作是[5,6,7]先与前面的最后一个元素 4 执行[4|[5,6,7]],完了结果在和倒数
第二个 3 执行同样的操作。以此类推，后面的元素长度不影响操作，但是前面的元素如果太长就会耗好长时间。
** 字符串是对应编码的证书列表
** 字符串打印
shell 会判断所有字符串字符是不是可打印字符，如果都是则打印成字符，如果有一个不是就全部打印成编码
的证书列表。
** 列表需要遍历，用来保存中介数据
** spawn_opt(fun() -> do() end, [link])的竞态条件 
先派生进程然后创建链接的问题在于，有可能新进程在链接创建之前终止，其他进程就无法收到进程终止的通知。
spawn_link 没有竞态条件,可以保证进程创建与链接的原子性。用这些方法启动进程会返回子进程 ID 给父进程，但
子进程却对父进程一无所知，因此，如果子进程想要和父进程通信，可以在启动时在 spawn_*里面带上父进程的 Id。
** 注册进程
适用于单例进程，一般都是系统服务, 这些服务在每个运行时系统中同一时刻最多只能有一个实例。
** ets 的结果为什么是 tupleList 的形式？
首先保存为什么要是{}的元组形式，因为 ets 将元组的第一个元素作为索引，这样可以使用第一个元素来查询。
查询结果放在[]里面是因为，ets 表有四种类型，对于同键表第一个元素可以重复，查询结果也就会有多个了。
** Erlang 的三类异常
*** error 运行时异常
*** exit 用于通报进程即将停止，不算意外事件，不会被记录到错误日志管理器
| exit/1: 这是进程终止前发出的消息     |
| 而 exit/2 则是发送给某个进程让其终止。 |

*** throw 这类异常用以处理用户自定义的情况
* gen_server 行为模式 
** 行为模式的三个概念
行为模式接口: 六个回调函数
行为模式实现: 回调函数里要实现的内容
行为模式容器: 执行同样的代码的一些进程，可以通过 gen_server:start_* 生成, 有多例进程和单例进程区别。
** 为什么使用行为模式的模块需要 behaviour 属性？
行为模式的六个回调一个都不能少，如果有 behaviour 属性，编译的时候会检测是否出现少了哪个部件。
** gen_server 怎么知道消息是给 handle_call 还是 handle_cast 还是 handle_info 的？
进程之间的消息传递：其实传给 call/2 或 cast/2 的消息数据参数只是消息 payload，凡是发送的时候会在外层加上
一层元数据，这样才知道这个消息该哪个回调函数使用。
** ! 是异步发送消息的
** gen_server:call()可以设置超时，如果等待超过这个时间就放弃等待
** gen_server:start_link 的单例服务和多例服务
gen_server:start_*/3,4 启动容器进程，/4 的第一个参数是 gen_server 注册名，/3 则没有注册名，容器进程不用注册，
属于多例进程。我们知道进程的通信要知道消息发往哪个进程，单例进程因为有注册名，可以知道这个进程，多例进程
则需要客户端维护这个进程 PID，这样调用回调的函数才能通过进程名与服务器通信。

单例服务是一种建立系统级服务的手法，这些服务在 Erlang 节点上只能有一个实例(命名为 local),甚至在集群上只能
有一个(命名为 global).
** gen_server 接口
   gen_server:** 函数接口都是对用户屏蔽的，他们都是通过一个函数在内部调用的。
*** gen_server:start_link/3,4  派生出一个 gen_server 容器进程
#+BEGIN_SRC
gen_server:start_link({local, ?SERVER}, ?MODULE, [Opts], [])  %% 单例进程
gen_server:start_link(?MODULE, [Opts], [])                    %% 多例进程
#+END_SRC
参数 1 是容器进程的注册名, 在调用回调的时候第一个参数就是服务器名字, 如果没有则进程不会被注册。
参数 2 指出行为模式实现位于那个回调模块中。
参数 3 是 init 执行的参数，会送给 init。
参数 4 是附加参数列表，可以留空。

然后调用 init 执行完之后返回, 至此服务器启动完成并执行完所有初始化工作，准备接受消息了。在没有完成 init 调
用之前会一直阻塞在 gen_server:start_link 处。

返回{ok, State, TIMEOUT}, TIMEOUT 是可选的, 如果 init 有比较耗时的操作，可以执行完必须的部分之后，设置 TIMEOUT
为 0 返回，触发延时，有 handle_info 来执行耗时的初始化操作,即延迟的初始化操作。

*** gen_server:call(?SERVER, Msg)  调用该函数后会挂起等待应答(可以设置超时时间)
参数 1 必须是服务器进程的注册名或者进程 ID。
参数 2 要发送的消息。
服务器收到消息并处理完毕之后，会将应答回传给发起请求的进程，gen_server:call/2 会负责接收应答并将之作
为函数调用的结果返回。

*** gen_server:cast(?SERVER, Msg)  调用该函数者发送消息之后立刻返回，不会挂起等待应答

** gen_server 的回调, 注意返回值
*** init([])
返回{ok, State=#state, ?TIMEOUT}
TIMEOUT=0 表示立刻触发延时，这样会产生一个 timeout 的带外消息，这个消息将会被 handle_info 处理.
在 init 中返回这个 0 的超时时间，作用主要是为了尽快结束 init，以免 start_link 挂起；同时可以把本来应该在 init 中
进行的一些超时的操作通过设置超时时间 0，发送带外消息，让 handle_info 来处理, 也就是可以把 timeout 的 handle_info
作为延迟的初始化操作。
*** handle_call(Msg, From, State)
返回:
| {reply,Reply,NewState}           |
| {reply,Reply,NewState,Timeout}   |
| {reply,Reply,NewState,hibernate} |
| {noreply,NewState}               |
| {noreply,NewState,Timeout}       |
| {noreply,NewState,hibernate}     |
| {stop,Reason,Reply,NewState}     |
| {stop,Reason,NewState}           |
reply 表示打算给调用 gen_server:call/3 方(或 From)一个回复，回传给调用方的值是 Reply,最后是服务器的新状态(如果有改变的话)

noreply 表示 gen_server 将会以 NewState 继续执行，任何给 From 的回应都应该显示通过 gen_server:reply 发送。 

第三个参数如果是 Timeout(ms)，那么到时间还没回应就会发送一个 timeout 的带外消息，随机执行 handle_info 的 timeout 字句 。
第三个参数如果使用 hibernate 代替 timeout，那么在等待下一个消息来临时就会通过 calling proc_lib:hibernate/3 执行 hibernate，
这个函数会执行一些垃圾回收的工作。

*** handle_cast(Msg, State)
没有 From 参数，返回 Msg 给服务器, 不用返回给调用方。
*** handle_info 带外消息
除了 call 和 cast 发送的消息都是带外消息，这类消息也会放进进程的信箱，由 handle_info 处理。
通过{active，true}设置的 socket 主动推送来的消息也属于带外消息。


*** 回调的返回值总结

** gen_server 的超时时间使用

* Supervisor
** application 行为模式
主动运用是有生命周期的，所以配有一个 application 的行为模式的实现模块，这个模块用来实现系统启动逻辑。它
至少要负责根监督者的启动,将根监督者作为运用中其他所有进程的鼻祖, 运用行为模式的实现模块通常命名为<app>_app。 
这个模块就是元数据中的 mod。

该行为模式只有两个回调 start/2 和 stop/1，也没有任何用户 API。stop 很简单，不述。
start(_Type, _StartArgs)会在 app 即将启动时调用这个函数，它负责完成实际的启动工作并以{ok, SupPid}返回。
其他各种需要在应用启动时完成的任务，如配置文件的读取、ets 表的初始化等都应该在这里启动, 最重要的是在
这里调用<app>_sup:start_link()启动根监督者。

Type 一般取值 normal，StartArgs 就是元数据中传给 mod 的参数。

自动运用的目的在于启动个一个或者多个进程以完成特定的任务，为了加强控制，这些进程应该由监督者(也就是实现
了 supervisor 行为模式的进程)统一派生和管理(重启，终止)。本质上在运行时，运用就是一棵由监督树和工作进程共
同构成的进程树，树根就是根监督者。

** supervisor 行为模式 
实现模块命名为<app>_sup.erl
*** supervisor 的启动
supervisor:start_link/2,3 有两种方式启动，包含两个参数或者三个参数。如果是三个参数，第一个就是 supervisor 的注册名，
他会调用 register 进程注册(当然 local 和 global 使用的注册函数不一样,可参考 man 手册), 如果没有第一个注册名参数，那么 supervisor
就不会被注册，这样在 observer 等工具里面看到的就只是 Pid。

什么时候使用注册名，什么时候不适用呢？ 当 supervisor 是动态启动的时候就可以不用注册名了，当然也可以按某种规则加上一个
注册名。
 
实现模块只有用户函数 start_link 调用 supervisor:start_link({local,?SERVER}, ?MODULE, [Opts])，以及回调 init/1.
当然还有 supervisor:start_child 等接口函数适用其他场合。

init/1 回调函数定义了子进程的启动策略、管理策略以及监督者进程本省的行为都是经由该函数的返回值告知 OTP 监督
者库的。 返回值{ok, {RestartStrategy, Children}}

*** 子进程重启策略
{How, Max, WithIn}:
How 规定重启规则：
| one_for_one        | 该监督树下的某个进程终止，不影响其他进程，只重启该进程.     |
| one_for_all        | 该进程终止，则同属一个监督树的进程全部重启.                 |
| rest_for_one       | 该进程终止，则在该进程后面启动的进程全部按顺序重启.         |
| simple_one_for_one | 这是 one_for_one 的简化版，所有的子进程都是同类进程且动态添加 |
通过 supervisor:start_child(SupPid, ChildSpec)启动的进程如果进程是同类的就使用 simple_one_for_one 类型的监督树，
如果是不同类的进程还是要使用其他类型。

Max 和 WithIn 共同确定最大重启频率，表示在 WithIn(s)内最多重启 Max 次，一旦超过这个限度，监督者就会在终止所有子
进程后自行了断，并顺着往上汇报故障信息。最大重启频率没有推荐值，不过生产上设置为 3600s 几次(10 次)。

*** 子进程规范
{ChildID, Start,Restart,ShutDown,ChildType,DepMods}

| ChildID   | 原子类的标签，用来在 supervisor 内部识别子进程规范的名字.                                               |
| Start     | {M, F, A}, 用户 API 调用 gen_server:start_*(?MODULE,ArgB, [])时 ArgB 会并入参数 A.                          |
| Restart   | permanent:终止都要重启;temporary:永不重启;transient:仅以外终止时重启.                                 |
| ShutDown  | (ms)给 Shutdown 时间给进程自我了断(时间内收到 exit 退出消息);brutal_kill 立即关闭;infinity:给充分时间关闭. |
| ChildType | worker 还是 supervisor.                                                                               |
| DepMods   | List,表示依赖的模块，仅用于代码热升级时告知系统该以何种顺序升级各个模块.                              |

在使用 supervisor 时，用户不能直接调用进程的用户启动接口，应该由 supervisor 来启动，这样才能接受监督。

在 init 回调中会指定子进程规范，注意，指定了这个子进程规范(你可能在该 sup 下面有多个子进程规范),在启动 supervisor 时就会启动一个
该类型的子进程。所以如果你的子进程是不确定的，那就不要在这个指定子进程规范(子进程规范可以为空[], rabbitmq 就有这种空[])，你
可以选择在调用 supervisor:start_child 的时候再指定子进程规范。

如果在 init 中规定了子进程规范，而且已经有一些参数。有时候 supervisor:start_child 的第二个参数不是子进程规范，而是另外的一些参数
列表，这时候会根据 init 中的子进程规范启动，只是 start_child 中的参数后合并在 init 中子进程规范的参数后面。

默认情况下，一旦接收到来自相互 link 的其他进程的其他进程的退出信号， 进程就会退出。为了避免这种行为并捕捉接受到的退出信号，
进程可以设置 trap_exit 标志：
process_flag(trap_exit,true).
这样，除了不能捕捉 kill 信号以外，外来的退出信号都会被转化成无害的消息{'EXIT',Pid, Reason}, 不会让接受者也终止。

* 事件处理和日志系统 
** 事件处理框架是标准 OTP 日志系统的基础 
** SASL 日志系统 
SASL 要起作用需要一些预备工作，当你以 gen_server 和 supervisor 等行为模式构建运用的时候，SASL 日志系统才能起作用,
否则自己编写的就得不到 SASL 的那些详细的日志信息了。比如你使用 spawn 启动一个进程，就得不到 SASL 的日志信息，但是
可以通过 proc_lib:spawn 来启动就可以得到相关信息，因为 proc_lib 模块是 stdlib 运用的一部分，利用他可以按照 OTP 的方
式启动进程,他会按照 OTP 的一些必要规范对进程进行设置。因此，如果你吃多了没事干，一定要自己编写脱离现成的行为
模式的进程，那就最好使用 proc_lib 来启动进程。
** gen_event
*** 没有 start_link, 进程终止跟着终止
    和 gen_server 一样，gen_event 启动时也有一个注册名，这里是标准系统进程 error_logger，我们可以把自定义的事件
处理器添加到这个标准进程中。
*** gen_event 行为模式的实现
    可以通过该实现定义自己的错误日志记录器，这样的目的是你可以根据你现有的日志格式使 erlang 的日志输出和你的
相匹配。比如可以得到你需要的格式保存到你自己的数据库等等。
    也有 handle_call,handle_info,terminate,code_change，此外 handle_event 替换了 gen_server 中的 handle_cast.
正是 handle_event 接收错误日志的, 所以在自定义的错误日志记录器，你可以根据你自己的需要来编写 handle_event 函数。
*** error_logger API 挂载自定义错误日志记录器 
    error_logger 有一个专门用于添加报告处理其的 API 函数 error_logger:add_report_handler(?MODULE)，有了他你就无
需关心时间处理器进程的定位问题了，该函数知道应该把处理器添加到哪个进程，并会连同该进程的注册名一起将调用委托
给 gen_event:add_handler/3.

* 分布式 Erlang/OTP 
集群就数量而言，在同一个集群里启动几十个节点没什么问题，但是要跑上几百个就悬了，其原因是机器之间的联络时需要
一定的通信开销的，而 Erlang 集群有是一个全联通网络，这样一来这部分开销就会随节点数的增加按平方规模增长。

为了一定程度上解决这个问题，借助一些特殊的节点，我们可以将多个集群合并成更大、非全联通的集群。这类节点经过特殊
的配置，不会对外传播其他节点的信息，他们甚至可以对其他节点隐身，一边对集群进行非侵入式监控。

分布式编程的两个基础：
| 复制式进程通信 | 消息传送是以消息副本的形式发送的                                        |
| 位置透明性     | 进程间的通信方式与接收方在本地还是在远程机器上无关, !发送具有位置透明性 |

** EPMD(Erlang Port Mapper Daemon) Erlang 端口映射守护进程---定位其他节点
   你每启动一个节点，它就会检查本地机器上是否运行者 EPMD，如果没有，就会自行启动 EPMD。EPMD 会追踪在本地机器上运
行的每一个节点(即所有的 erlang 节点，包括 emqttd 的，rabbitmq 及其他的所有 Erlang 节点)，并记录分配给他们的端口号。可
以通过 net_adm:names() 得到本机上运行的所有 erlang 节点的节点名和端口：比如
#+BEGIN_SRC
(emqttd1@127.0.0.1)3> net_adm:names().
{ok,[{"rabbit",41789},{"emqttd1",39385},{"emqttd2",55640}]}
#+END_SRC
可以看出返回了本机上运行的三个 Erlang 节点，一个是 rabbitmq 的，两个是 emqttd 的，同时返回的还有相应的端口号。当一台
机器上的 Erlang 节点试图与某远端节点通信时，本地的 EPMD 就会联络远程机器上的 EPMD(默认使用的是 TCP/IP，端口 4369)，询
问在远程机器上有没有叫相应名字的节点,远端的 EPMD 就通过上面的方法知道本机上运行的所有节点和端口号，如果有对方要连
接的节点，远程的 EPMD 就会回复相应节点对应的端口号，通过该端口号就可以与远程节点通信。不过 EPMD 不会主动搜寻其他 EPMD，
只有在某个节点主动搜寻其他节点时通信才能建立。 可以通过 ps ax | grep -i epmd 查看。

接下来是节点的互连，如果只是建立连接，最简单的就是采用标准库函数 net_adm:ping(NodeAtom)，如果返回 pong 相应，那就 
说明和远端节点建立了连接了。目前新的 OTP 使用 net_kernel:connect_node('xxx@ip') 进行连接，最后可以通过 nodes()查看
是否已经建立了连接。

这样建立连接可能出现一些问题，最大的就是可能很多人都可以通过上面的方式连接到你的节点上，这是很危险的，为了处理
这个问题，于是在每个节点上设置一个 cookie，只有具备相同 cookie 的节点才能通过认证获得连接。

** cookie
*** cookie 的作用
    Erlang 节点只有在知晓其他节点的 cookie 的情况下才能与之通信。
*** cookie 的设置
读写：
    | 可以通过 vm.args 中通过 setcookie 来设置,也可以启动之后随机生成在$HOME/.erlang.cookie 中再复制到其他机器 |
    | 可以通过 erlang shell 中 auth:get_cookie()来获取                                                       |
应该保证：
    | 集群的节点使用的 cookie 应该值保证相同                     |
    | cookie 的值应该是一个不易被猜中的值                       |
    | 除文件所有者外的其他用户对 cookie 只有读的权限没有写的权限 |

* Mnesia 分布式存储
  注意 mnesia 的分布式存储不等于 Erlang 建立集群。没有 mnesia 同样可以实现 Erlang 的集群，只要节点
间建立了通信联系，也就实现了集群。
** 分布式表
** Mnesia 适用范围
| 不应该用于管理分布于数十台机器上数百 G 的持久化数据. |

| 适用于冗余度较低，尺寸较小的数据存储需求     |
| 大小适中的(基于磁盘的)持久化数据             |
| 需要跨进程共享的运行时数据                   |
| 处于容错和性能的考虑需要将数据分布至多个节点 |
** Mnesia 的 dirty 操作
dirty 操作在执行时不会考虑事务或数据库锁，使用他们时需要格外消息。
比起事务,脏操作要快的多。正确运用脏操作可以大大提高运用的执行速度，但没考虑清除后果就滥用脏操作的话，很可能会导致数据
不一致。一般来说，脏读比脏写要安全；但是不管如何，只要你心存疑虑，就请使用事务。
** Mnesia 的索引
Mnesia 可以在创建表的时候通过选项 index 创建索引。索引其实就是一些额外的表，用于加速非主键字段的查询。在创建索引时请务必牢记，
索引会占用额外的空间，更重要的是主表上的每一次写操作都会更新索引，这将导致启动速度和写入速度变慢。所以使用索引要权衡利弊。
** Mnesia 加入集群
   必须有一个节点是独自完成启动过程的, 如果两个同时启动就可能会出现竞态现象，导致双方都认为对方是先启动的那一个, 后果就是
初始化数据库模式永远也建立不起来。
第一确保 mnesia 正常启动；
与此同时清理掉本地节点上现存的数据库模式, 清除数据库之前必须先停止 Mnesia。
*** 先有一个独立启动的节点, 上面将会建立初始的 schema
*** mnesia:stop() 然后 mnesia:delete_schema([node()]) 
*** mnesia:change_config(extra_db_nodes,[Node]) 
让 Mnesia 再向数据库中添加一个节点.Mnesia 的工作方式和 Erlang 节点类似：只要连上一个实例，就可以与所有实例联通，因此只
需要添加一个远程实例就行了。

要注意的是，应该有新的空白节点向已经存有数据的节点发起。如果连接成功首先在本地节点上复制一份远程数据库的模式。该模式
会取代本地的临时空白模式(其实本地的已经在 delete 的时候就清除了)。复制完模式之后在复制其他可复制的数据, 这样就实现了 Mnesia 的分布式。
*** mnesia:add_table_copy(schema,node(),ram_copies)
*** mnesia:wait_for_copy(mnesia:system_info(tables), TIMEOUT)
等待各表的内容同步完毕。

*** Mnesia 的操作有很多需要是必须成功的，不成功则成仁， 这个确保工作要做好。
    
    
** Mnesia 分布式实际运用的部署
   为了保证 Mnesia 元数据的不丢失，在布置节点时，我们通常首先启动一个节点，在把其他节点连接到这个节点上。在运用时，这个节点
不连接任何客户端，也就是置为分布式集群而生，不执行实际的业务。由于不执行实际的业务，所以，它就不容易崩溃。

* Web 服务器
** 自定义行为模式
是一个库运用，无法启动的，只能被调用。
*** 自定义行为模式的要素
1  至少要导出一个函数 behaviour_info(callbacks)函数，供编译的时候调用来获得该 behavior 所有的回调，然后检查编译的模块
中是否包含全部规定的回调函数。

2  行为模式的接口函数，供使用者调用，比如启动进程的接口以及必要的实现函数。

3  进程初级的处理函数，这些函数会根据不同的情况指出该调用用户定义的行为模式实现函数。

4  后面就是用户自己定义的行为模式的实现函数了。

** TCP 流量控制和主/被动套接字
在主动模式下{active, true}，套接字上有多少数据 Erlang 运行是系统就会读多少数据，一旦读完立即以 Erlang 消息的形式传递给持
有套接字的进程。如果客户端的发送速度比接收方的读取速度快，那么消息就会不断增长并最终将内存耗尽。在被动模式下{active,false}，
持有套接字的今晨给必须显式地通过 gen_tcp:read()来读取套接字中的数据，这么多就会增加代码的复杂度，但是却可以更精确地控
制系统接收数据的时机和速率，还可以依靠 TCP 内置的流量控制功能来自动限制发送方的发送速度。

还有一种结合上面两种方式的 once 模式{active,once}， 该模式下，可以将套接字临时置为主动模式，等套接字再次受到数据，并以
Erlang 消息的形式将数发送给持有者进程之后，套接字被自动重置为被动模式，TCP 内置的流量控制也随之生效。

* Erlang 的原则
** 边界检查
当数据从不可信的外部世界进入可信的内部区域时应该对数据进行检查，这是 Erlang 程序设计的原则。
** 服务器不该调用自身
也就是说，服务器不该调用那些调用了 gen_server:call/cast 函数的函数，因为这样可能会是服务器进入循环等待
状态而陷入死锁。
** ETS 使用情况
| 不需要集群共享，只需单节点进程共享.           |
| 需在 vm 运行期间持久化，与节点共存亡.           |
| 访问速度要快.                                 |
| 数据结构相对平坦，最好不要与其他表有外键关系. |
** 运用行为模式和监督行为模式尽量简单，少耦合
尽量不要在 supervisor 模块中插入运用代码。仅在顶层的 init 中插入少量代码尚可，否则一旦出什么乱子，整个运用都无法启动。
** 创建 OTP 运用的骨架步骤
目录--xxx.app 元数据文件---运用行为模式实现模块 xx_app.erl---supervisor 行为模式实现 xxx_sup.erl ---子进程启动和实现
** 
