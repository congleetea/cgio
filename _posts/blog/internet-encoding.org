#+TITLE:       编解码
#+AUTHOR:      congleetea
#+EMAIL:       congleetea@m6
#+DATE:        2017-04-11 Tue
#+URI:         /blog/%y/%m/%d/编解码
#+KEYWORDS:    internet,encode,decode,mime,utf8,base64
#+TAGS:        points,internet
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil ::t |:t ^:nil -:nil f:t *:t <:t
#+DESCRIPTION: 浅浅地看看物联网中的编解码

| 什么是字符集。               |
| 什么是字符编码。             |
| 为什么会出现各种编码方式。   |
| 常用的编码方式以及使用场景。 |

* 概述

[[http://www.cnblogs.com/skynet/archive/2011/05/03/2035105.html][这篇博文中]] 对字符编码给出了清晰的认识，主要需要明确:

1 计算机中存储的信息都是用二进制表示的，也就是说我们在屏幕中看到的文字，图片，视屏；听到的声音等等都是用二进制来储存的，从二进制数据转化过来给我们看和听的。

2 通俗的说，按照何种规则将字符存储在计算机中，如'a'用什么表示，称为"编码"；反之，将存储在计算机中的二进制数解析显示出来，称为"解码"，如同密码学中的加密和解密。在解码过程中，如果使用了错误的解码规则，则导致'a'解析成'b'或者乱码。

3 字符集（charset）：是一个系统支持的所有 *抽象字符的集合* 。字符是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。

4 字符编码（Character Encoding）：是一套法则，使用该法则能够对自然语言的字符的一个集合。即在符号集合与数字系统之间建立对应关系，它是信息处理的一项基本技术。同一个字符在不同的字符编码规则里可能会表示成不同的二进制形式。不同的编码规则也可以相互转换。当然由于历史和文化地域的原因，不同的编码规则对不同的字符编码有所限制, 比如英语只需要ASCII就足矣, 但ASCII对其他语言就不够。

* 常用的字符集和字符编码

常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。

[[http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html][阮一峰的这篇文章]] 浅显地解释了字符编码的历史过程。

- ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）编码系统

一个字节是8位，从00000000到11111111总共可以编码256个字符。但是对于英语只需要后七位7个bits就足够了，这就是ASCII编码系统，ASCII码一共规定了128个字符的编码，比如空格"SPACE"是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。

- 非ASCII编码

一些欧洲国家的字符不同于英语字符，为了表示这些字符，他们就用上了一个字节的最高位，这样他们就可以表示256个字符，当前前面0~127和ASCII一样的，不一样的就128~255这一段，因此这一段的同一个二进制表示不同语言的时候会解释成不同的字符。

这255个表示这些欧洲国家的字符足够了，但是再远一点，亚洲国家的字符更多，一个字节显然无论如何也不够了，那怎么办？于是就开始使用不止一个字节来表示不同的字符。

- Unicode（万国码、国际码、统一码、单一码）

它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。

这里就有两个严重的问题，第一个问题是，如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。
它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。

Unicode的实现方式不同于编码方式。一个字符的Unicode编码是确定的。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对Unicode编码的实现方式有所不同。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF）, Unicode的实现方式由很多：utf-8, UTF-7、Punycode、CESU-8、SCSU、UTF-32、GB18030等  

Unicode编码指的是UCS-2(Universal Character Set)编码方式，即直接用两个字节存入字符的Unicode码。

- 大端小端
Unicode码可以采用UCS-2格式直接存储。也就是使用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。
那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？
Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做"零宽度非换行空格"（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。
如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。
 
- utf-8
UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示）。

UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~4个字节表示一个符号，根据不同的符号而变化字节长度。规则如下：

1  Unicode中单字节的符号，最高位设为0，后面7位是这个符号的Unicode码。也就是和ASCII码相同。

2  Unicode是多字节的符号(n>1)，第一个字节的前n位都设为1，第n+1位设为0，后面的字节前两位都以10开头，剩余的所有字节的空位就是字符的Unicode码填充。总结如下：

| Unicode符号范围     | UTF-8编码方式                       |
| (十六进制)          | （二进制）                          |
|---------------------+-------------------------------------|
| 0000 0000-0000 007F | 0xxxxxxx                            |
| 0000 0080-0000 07FF | 110xxxxx 10xxxxxx                   |
| 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx          |
| 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx |

* MIME("Multipurpose Internet Mail Extensions"，中译为"多用途互联网邮件扩展")
这不是字符编码方式，而是一系列的电子邮件技术规范。传统的电子邮件是1982年定下技术规范的，文件是RFC 822。
它的一个重要特点，就是规定电子邮件只能使用ASCII字符。这导致了三个结果：1）非英语字符都不能在电子邮件中使用；2）电子邮件中不能插入二进制文件（如图片）；3）电子邮件不能有附件。
这实际上无法接受的，因此到了1992年，工程师们决定扩展电子邮件的技术规范，提出一系列补充规范，这就是MIME的由来。

因此电子邮件的传统格式不支持非ASCII编码和二进制数据，这样非ASCII的字符集就需要进行转码之后才能通过电子邮件传输。转码方式通过Content-transfer-encoding指定，Content-transfer-encoding的值有5种----"7bit"、"8bit"、"binary"、"quoted-printable"和"base64"----其中"7bit"是缺省值，即不用转化的ASCII字符。真正常用是"quoted-printable"和"base64"两种。

- Quoted-printable(可打印字符引用编码)
它主要用于ACSII文本中夹杂少量非ASCII码字符的情况，不适合于转换纯二进制文件。

他把一个字节用三个字符来表示，规则是第一个字符统一为"="， 第二和第三个字符分别是字节的高四位和第四位。比如ASCII码中"换页键"（form feed）是12，二进制形式是00001100，写成十六进制就是0C，因此它的编码值为"=0C"。"="号的ASCII值是61，二进制形式是00111101，因为它的编码值是"=3D"。除了可打印的ASCII码以外，所有其他字符都必须用这种方式进行转换。
所有可打印的ASCII码字符（十进制值从33到126）都保持原样不变，"="（十进制值61）除外。

- base64

所谓Base64，就是说选出64个字符----小写字母a-z、大写字母A-Z、数字0-9、符号"+"、"/"（再加上作为垫字的"="，实际上是65个字符）----作为一个基本字符集。然后，其他所有符号都转换成这个字符集中的字符。

| 数值 | 	字符	 | 	数值	 | 字符	 	 | 数值	 | 字符	 	 | 数值 | 	字符 |
|------+----------+----------+-----------+--------+-----------+------+--------|
| 0	  | A	      | 16	     | Q	       | 32	   | g	       | 48	 |      w |
| 1	  | B	      | 17	     | R	       | 33	   | h	       | 49	 |      x |
| 2	  | C	      | 18	     | S	       | 34	   | i	       | 50	 |      y |
| 3	  | D	      | 19	     | T	       | 35	   | j	       | 51	 |      z |
| 4	  | E	      | 20	     | U	       | 36	   | k	       | 52	 |      0 |
| 5	  | F	      | 21	     | V	       | 37	   | l	       | 53	 |      1 |
| 6	  | G	      | 22	     | W	       | 38	   | m	       | 54	 |      2 |
| 7	  | H	      | 23	     | X	       | 39	   | n	       | 55	 |      3 |
| 8	  | I	      | 24	     | Y	       | 40	   | o	       | 56	 |      4 |
| 9	  | J	      | 25	     | Z	       | 41	   | p	       | 57	 |      5 |
| 10	 | K	      | 26	     | a	       | 42	   | q	       | 58	 |      6 |
| 11	 | L	      | 27	     | b	       | 43	   | r	       | 59	 |      7 |
| 12	 | M	      | 28	     | c	       | 44	   | s	       | 60	 |      8 |
| 13	 | N	      | 29	     | d	       | 45	   | t	       | 61	 |      9 |
| 14	 | O	      | 30	     | e	       | 46	   | u	       | 62	 |      + |
| 15	 | P	      | 31	     | f	       | 47	   | v	       | 63	 |      / |

因为，Base64将三个字节转化成四个字节，因此Base64编码后的文本，会比原文本大出三分之一左右。如果剩下字符不足三个字节，上下的就用0填充，输出字符使用"="。

比如abc表示成二进制是:01100001 01100010 01100011

分成四个六位(从前面开始分组)： 011000 010110 001001 100011

分别是10进制的： 24,22,9,35

对应上表的字符就是YWJj

| 字符 | 三字符分组 | 二进制                     | 分成六位                         | 对应十进制     | base64编码 |
|------+------------+----------------------------+----------------------------------+----------------+------------|
| abc  | abc        | 01100001 01100010 01100011 | 011000 010110 001001 100011      | 24,22,9,35     | YWJj       |
| abcd | abc d      | 同上, 01100100             | 同上,011001 000000,还差两位补"=" | 同上，25,0,0,0 | YWJjZA==   |

- base62

Base62编码与Base64编码类似，但是他没有+和/，只有数字和字母组成。
